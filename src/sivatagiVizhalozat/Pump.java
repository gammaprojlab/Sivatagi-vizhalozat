package sivatagiVizhalozat;
//

//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Sivatagi Vizhalozat
//  @ File Name : Pump.java
//  @ Date : 03/04/2023
//  @ Author : 
//
//

/**
 * This class manages the pump. It handles all of it functions, like changing
 * the direction of pumping
 * or the breaking of the pump at random moments.
 */
public class Pump extends FieldElement {

	/**
	 * It storest what the next created Pump's ID will be.
	 * After creating a new Pump this counter will increase by one.
	 */
	private static int nextId;
	
	/**
	 * It stores the state of the pump, if it working and can pump water into the
	 * output pipe
	 */
	private boolean isWorking;

	/**
	 * It stores how much water the pump can hold
	 */
	private int tankCapacity;

	/**
	 * The index of the input pipe which is stored in the connections. This is where
	 * the pump sucks the water from
	 */
	private int input;

	/**
	 * The index of the output pipe which is stored in the connections. This is
	 * where the pump pumps the water
	 */
	private int output;

	/**
	 * The amount of water that is currently in the pipe
	 */
	private int water;

	/**
	 * Get the value of the isWorking variable of this pump operates properly or not
	 * 
	 * @return True if the pump is working and false otherwise
	 */
	public boolean getIsWorking() {
		return isWorking;
	}

	/**
	 * Sets the isWorking variable to the given value
	 * 
	 * @param w The value to set the isWorking variable
	 */
	public void setIsWorking(boolean w) {
		isWorking = w;
	}

	/**
	 * Get the value of tankCapacity
	 * 
	 * @return The maximum amount of water the pump can hold
	 */
	public int getTankCapacity() {
		return tankCapacity;
	}

	/**
	 * Set the value of tankCapacity
	 * 
	 * @param tC The maximum amount of water the pump can hold
	 */
	public void setTankCapacity(int tC) {
		tankCapacity = tC;
	}

	/**
	 * Get the index of the input pipe
	 * 
	 * @return The index of the input pipe
	 */
	public int getInput() {
		return input;
	}

	/**
	 * Get the index of the next pipe, that will be created.
	 * 
	 * @return The index of the next pipe
	 */
	public static int getNextId() {
		return nextId;
	};

	/**
	 * Set the index of the next pipe, that will be created.
	 */
	public static void setNextId(int id) {
		nextId = id;
	};

	/**
	 * Set the index of the input pipe, if i is -1, it means that the input is
	 * closed
	 * 
	 * @param i The id of the input pipe in the pump's connections
	 */
	public boolean setInput(int i) 
	{
		if(i == -1)
		{
			input = -1;
			return true;
		}
		for(FieldElement pipe: connections)
		{
			if(pipe.getId() == i) {
				input = i;
				return true;
			}
		}
		return false;
	}

	/**
	 * Get the index of the output pipe
	 * 
	 * @return The index of the output pipe
	 */
	public int getOutput() {
		return output;
	}

	/**
	 * Set the index of the output pipe, if o is -1, it means that the output is
	 * closed
	 * 
	 * @param o The index of the output
	 * @return 
	 */
	public boolean setOutput(int o) 
	{
		if(o == -1)
		{
			output = -1;
			return true;
		}
		for(FieldElement pipe: connections)
		{
			if(pipe.getId() == o) {
				output = o;
				return true;
			}
		}
		return false; 
	}

	/**
	 * Get how much water is in the pump's tank currently
	 * 
	 * @return The amount of water that's in the pump's tank currently
	 */
	public int getWater() {
		return water;
	}

	/**
	 * Set how much water is in the pump's tank currently
	 * 
	 * @param w The amount of water to be set, if it's higher than the tankCapacity,
	 *          the new value will be the tankCapacity
	 */
	public void setWater(int w) {
		if (w <= tankCapacity && w >= 0)
			water = w;
		else if (w > tankCapacity)
			water = tankCapacity;
		else
			water = 0;
	}

	/**
	 * Pump's own toString to make tests more visually informative.
	 */
	public String toString () {
		String value = "";

		value += "id: " + id + "\n";
		value += "maxConnections: " + maxConnections + "\n";
		value += "isWorking: " + isWorking + "\n";
		value += "tankCapacity: " + tankCapacity + "\n";
		value += "water: " + water + "\n";
		value += "input: " + input + "\n";
		value += "output: " + output + "\n";
		value += "connections:\n";
			for(FieldElement p : connections){
				value += "Pipe";
				value += p.id;
				value += "\n";
			}
		value += "players:";
			for(Player p : players){
				value += "\n";
				value += p.getClass().getSimpleName();
				value += p.getId();
			}	
			
		return value;	
	}
	/**
	 * Default constructor. Calls parent's default constructor and sets 
	 * base values up. Then increases the nextId by one.
	 */
	public Pump() {
		super();
		id=nextId;
		nextId++;
		input = -1;
		output = -1;
		tankCapacity = 100;
		water = 0;
		setMaxConnections(5);
		isWorking = true;
	}

	/**
	 * Constructor with a Game parameter.Calls parent's 2 parametered 
	 * constructor and sets base values up. Then increases the nextId by one.
	 *
	 * @param g  The Game object where this element is being used
	 */
	public Pump(Game g) {
		super(5, g);
		id=nextId;
		nextId++;
		input = -1;
		output = -1;
		tankCapacity = 100;
		water = 0;
		isWorking = true;
	}

	/**
	 * Two parameter constructor
	 * Works similarly to the one parametered constructor.
	 *
	 * @param mc The maximum number of connections this element can have
	 * @param g  The Game object where this element is being used
	 */
	public Pump(int mc, Game g) {
		super(mc, g);
		id=nextId;
		nextId++;
		input = -1;
		output = -1;
		tankCapacity = 100;
		water = 0;
		isWorking = true;
	}

	/**
	 * Three parameter constructor
	 * Works similarly to the one parametered constructor.
	 *
	 * @param mc The maximum number of connections this element can have
	 * @param g  The Game object where this element is being used
	 * @param tC The maximum amount of water that the pump's tank can hold
	 */
	public Pump(int mc, Game g, int tC) {
		super(mc, g);
		id=nextId;
		nextId++;
		input = -1;
		output = -1;
		tankCapacity = tC;
		water = 0;
		isWorking = true;
	}

	/**
	 * Eight parameter constructor
	 * Works similarly to the one parametered constructor except, that 
	 * it sets every variable of the newly created Pump.
	 *
	 * @param mc The maximum number of connections this element can have
	 * @param g  The Game object where this element is being used
	 * @param tC The maximum amount of water that the pump's tank can hold
	 * @param w  The water that is currently in the Pump
	 * @param i  The intake Pipe's id.
	 * @param o  The exhaust Pipe's id.
	 * @param iw The boolean value that swts wether the Pump is working or not
	 * @param fixid The id of the Pump
	 */
	public Pump(int mc, Game g, int tC, int w, int i, int o, boolean iw) {
		super(mc, g);
		id=nextId;
		nextId++;
		input = i;
		output = o;
		tankCapacity = tC;
		water = w;
		isWorking = iw;
	}

	/**
	 * At random moments this function is called to break the pump. When the pump
	 * isn't working, it's not pumping to the output pipe
	 * nor sucking from the input pipe
	 */
	public void StopWorking() {
		if (isWorking) {
			isWorking = false;
		}
	}

	/**
	 * When this pump is broken, a Plumber can repair it using this function. When
	 * repaired it functions normally
	 */
	public boolean Repair() {
		if (!isWorking) {
			isWorking = true;
			return true;
		}
		return false;
	}

	/**
	 * Remove a pipe from connections
	 * 
	 * @param pipe The pipe to be removed
	 */
	public boolean Remove(FieldElement pipe) {
		if (pipe != null) {
			if (connections.contains(pipe)) {
				int id = pipe.getId();
				// If the removed pipe was the input pipe, close the input
				if (id == input)
					input = -1;
				// Same as the input pipe, if they're the same than close the output
				if (id == output)
					output = -1;
				connections.remove(pipe);
				return true;
			}
		}
		return false;
	}

	
	/**
	 * @param f The id of the pipe the player wants to disconnect from this field
	 * @return The disconnected pipe
	 */
	public Pipe Disconnect(int id) { 
		for (FieldElement p : connections) {
			if(p.getId() == id) {
				Pipe ret = p.Disconnect(p.GetNeighbor().indexOf(this));
				if(ret != null) {
					Remove(ret);
					return ret;
				}
			}
		}
		return null;
	}
	
	/**
	 * Both Plumbers and Sabouteurs can change the direction of pumping. If any of
	 * the two new values
	 * are incorrect, function will return false
	 * 
	 * @param i The index of the new input pipe
	 * @param o The index of the new output pipe
	 */
	public boolean ChangeDirection(int i, int o) {
		if((i != -1 && i != o) || (i == -1 && i == o)) {
			if(i == -1 || connections.contains(game.getMap().getPipe(i)) && o == -1 || connections.contains(game.getMap().getPipe(o))) {
				input = i;
				output = o;
				return true;
			}
		}
		return false;
	}

	/**
	 * The implementation of the Step1 function of the Steppable interface
	 * If Input is closed( = -1) Skip it
	 */
	public void Step1() {
		if (game.getRandom() * 100 > 80)
			StopWorking();
		if (isWorking && input != -1 && water != tankCapacity) { // If pump is working, the input is open and there's
																	// room for water in tank
			
			Pipe pipeInput = game.getMap().getPipe(input);
			if(connections.contains(pipeInput))
			{
				int w = pipeInput.SuckWater(water);
				if (water + w < tankCapacity)
					water += w;
				else
					water = tankCapacity;
			}
			else
			{
				input = -1;
			}
				 
		}

	}

	/**
	 * The implementation of the Step2 function of the Steppable interface
	 * If Output is closed( = -1) Skip it
	 */
	public void Step2() {
		if (isWorking && output != -1) { // If pump is working and output is open
			Pipe pipeOutput = game.getMap().getPipe(output);
			if(connections.contains(pipeOutput))
			{
				int w = pipeOutput.PumpWater(water);
				if (water - w >= 0)
					water -= w;
				else
					water = 0;
			}
			else
			{
				output = -1;
			}
		}
	}
}
