package sivatagiVizhalozat;
//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Sivatagi Vizhalozat
//  @ File Name : Pump.java
//  @ Date : 03/04/2023
//  @ Author : 
//
//

/**
 * This class manages the pump. It handles all of it functions, like changing the direction of pumping
 * or the breaking of the pump at random moments.
 */
public class Pump extends FieldElement {

	/**
	 * It stores the state of the pump, if it working and can pump water into the output pipe
	 */
	private boolean isWorking;

	/**
	 * It stores how much water the pump can hold
	 */
	private int tankCapacity;
	
	/**
	 * The index of the input pipe which is stored in the connections. This is where the pump sucks the water from
	 */
	private int input;
	
	/**
	 * The index of the output pipe which is stored in the connections. This is where the pump pumps the water
	 */
	private int output;
	
	/** 
	 * The amount of water that is currently in the pipe
	*/
	private int water;

	/**
	 * Get the value of the isWorking variable of this pump operates properly or not
	 * @return True if the pump is working and false otherwise
	 */
	public boolean getIsWorking() {
		Skeleton.Println(this.toString()+"getIsWorking()");
		Skeleton.Println("return null");
		return isWorking;
	}

	/**
	 * Sets the isWorking variable to the given value
	 * @param w The value to set the isWorking variable
	 */
	public void setIsWorking(boolean w) {
		Skeleton.Println(this.toString()+"setIsWorking("+ boolean.class.getSimpleName() + " " + ((w) ? "true" : "false") + ")");
		isWorking = w;
	}

	/**
	 * Get the value of tankCapacity
	 * @return The maximum amount of water the pump can hold
	 */
	public int getTankCapacity() {
		Skeleton.Println(this.toString()+"getTankCapacity()");
		Skeleton.Println("return " + tankCapacity);
		return tankCapacity;
	}

	/**
	 * Set the value of tankCapacity
	 * @param tC The maximum amount of water the pump can hold
	 */
	public void setTankCapacity(int tC) {
		Skeleton.Println(this.toString()+"setTankCapacity("+ int.class.getSimpleName() + " " + tC +")");
		tankCapacity = tC;
	}

	/**
	 * Get the index of the input pipe
	 * @return The index of the input pipe
	 */
	public int getInput() {
		Skeleton.Println(this.toString()+"getInput()");
		Skeleton.Println("return " + input);
		return input;
	}

	/**
	 * Set the index of the input pipe, if i is -1, it means that the input is closed
	 * @param i The index of the input pipe in the pump's connections
	 */
	public void setInput(int i) {
		Skeleton.Println(this.toString()+"setInput("+ int.class.getSimpleName() + " " + i +")");
		Skeleton.indentation++;
		if(i >= -1 && i < GetNeighbor().size()){
			input = i;
			Skeleton.indentation--;
		}
	}

	/**
	 * Get the index of the output pipe
	 * @return The index of the output pipe
	 */
	public int getOutput() {
		Skeleton.Println(this.toString()+"getOutput()");
		Skeleton.Println("return " + output);
		return output;
	}

	/**
	 * Set the index of the output pipe, if o is -1, it means that the output is closed
	 * @param o The index of the output
	 */
	public void setOutput(int o) {
		Skeleton.Println(this.toString()+"setOutput("+ int.class.getSimpleName() + " " + o + ")");
		Skeleton.indentation++;
		if(o >= -1 && o < GetNeighbor().size()) {
			output = o;
			Skeleton.indentation--;
		}
	}

	/**
	 * Get how much water is in the pump's tank currently
	 * @return The amount of water that's in the pump's tank currently
	 */
	public int getWater() {
		Skeleton.Println(this.toString()+"getWater()");
		Skeleton.Println("return " + water);
		return water;
	}

	/**
	 * Set how much water is in the pump's tank currently
	 * @param w The amount of water to be set, if it's higher than the tankCapacity, the new value will be the tankCapacity
	 */
	public void setWater(int w) {
		Skeleton.Println(this.toString()+"setWater("+ int.class.getSimpleName() + " " + w +")");
		if ( w <= tankCapacity && w >= 0 ) water = w;
		else if( w > tankCapacity) water = tankCapacity;
		else water = 0;
	}

	/**
	 * Default constructor
	 */
	public Pump() {
		super();
		Skeleton.Println(this.toString()+"Pump()");
		isWorking = true;
		tankCapacity = 0;
		input = -1;
		output = -1;
		water = 0;
	}

	/**
	 * Two parameter constructor
	 * @param mc The maximum number of connections this element can have
	 * @param g The Game object where this element is being used
	 */
	public Pump(int mc, Game g) {
		super(mc, g);
		Skeleton.Println(this.toString()+"Pump("+ int.class.getSimpleName() + " " + mc + ", " + Game.class.getSimpleName() + " " + g +")");
		isWorking = true;
		tankCapacity = 0;
		input = -1;
		output = -1;
		water = 0;
	}

	/**
	 * Three parameter constructor
	 * @param mc The maximum number of connections this element can have
	 * @param g The Game object where this element is being used
	 * @param c The maximum amount of water that the pump's tank can hold
	 */
	public Pump(int mc, Game g, int tC) {
		super(mc, g);
		Skeleton.Println(this.toString()+"Pump("+ int.class.getSimpleName() + " " + mc + ", " + 
		Game.class.getSimpleName() + " " + g + ", " + int.class.getSimpleName() + " " + tC + ")");
		isWorking = true;
		tankCapacity = tC;
		input = -1;
		output = -1;
		water = 0;
	}

	/**
	 * Four parameter constructor
	 * @param mc The maximum number of connections this element can have
	 * @param g The Game object where this element is being used
	 * @param c The maximum amount of water that the pump's tank can hold
	 * @param w The amount of water in the pump's tank
	 */
	public Pump(int mc, Game g, int tC, int w) {
		super(mc, g);
		Skeleton.Println(this.toString()+"Pump("+ int.class.getSimpleName() + " " + mc + ", " + 
		Game.class.getSimpleName() + " " + g + ", " + int.class.getSimpleName() + " " + tC + ", " + int.class.getSimpleName() + " " + w + ")");
		isWorking = true;
		tankCapacity = tC;
		input = -1;
		output = -1;
		water = w;
	}

	/**
	 * At random moments this function is called to break the pump. When the pump isn't working, it's not pumping to the output pipe 
	 * nor sucking from the input pipe
	*/
	public void StopWorking() {
		Skeleton.Println(this.toString()+"StopWorking()");
		Skeleton.indentation++;
		if(isWorking) {
			setIsWorking(false);
			Skeleton.indentation--;
		}
	}

	/**
	 * When this pump is broken, a Plumber can repair it using this function. When repaired it functions normally
	*/
	public boolean Repair() {
		Skeleton.Println(this.toString()+"Repair()");
		Skeleton.indentation++;
		if(!isWorking) {
			setIsWorking(true);
			Skeleton.Println("return true");
			Skeleton.indentation--;
			return true;
		}
		Skeleton.indentation--;
		return false;
	}

	/**
	 * Remove a pipe from connections
	 * @param pipe The pipe to be removed
	 */
	public boolean Remove(FieldElement pipe) {
		Skeleton.Println(this.toString()+"Remove("+FieldElement.class.getSimpleName()+" "+pipe+")");
		Skeleton.indentation++;
		if(pipe != null) {
			if(GetNeighbor().contains(pipe)) {
				int inx = GetNeighbor().indexOf(pipe);
				// If the removed pipe was the input pipe, close the input
				if(inx == input) input = -1; 
				// In this case the input pipe would get a higher index which could mean we point out of the list,
				// so we decrease the value to stop it from happening
				else if(inx < input) input--;
				// Same as the input pipe, if they're the same than close the output
				if(inx == output) output = -1;
				// Same as the input pipe, if the output index was higher, than when removing a lower indexed item
				// it could point to nothing or not the pipe we wanted
				else if(inx < output) output--;
				GetNeighbor().remove(pipe);
				Skeleton.indentation--;
				Skeleton.Println("return true");
				return true;
			}
		}
		Skeleton.indentation--;
		Skeleton.Println("return false");
		return false;
	}

	/**
	 * Both Plumbers and Sabouteurs can change the direction of pumping. If any of the two new values
	 * are incorrect, function will return false
	 * @param i The index of the new input pipe
	 * @param o The index of the new output pipe
	*/
	public boolean ChangeDirection(int i, int o) {
		Skeleton.Println(this.toString()+"ChangeDirection("+ int.class.getSimpleName() + " " + i + ", " + Game.class.getSimpleName() + " " + o +")");
		if(i >= -1 && o >= -1 && i < GetNeighbor().size() && o < GetNeighbor().size() && i != o) {
			input = i;
			output = o;
			Skeleton.Println("return true");
			return true;
		}
		Skeleton.Println("return false");
		return false;
	}
	
	/**
	 * The implementation of the Step1 function of the Steppable interface
	 * If Input is closed( = -1) Skip it
	 */
	public void Step1() {
		Skeleton.Println(this.toString()+"Step1()");
		Skeleton.indentation++;
		if(Math.random() * 100 < 20) StopWorking();
		if(isWorking && input != -1 && water != tankCapacity) { // If pump is working, the input is open and there's room for water in tank
			int w = GetNeighbor().get(input).SuckWater(tankCapacity - water);
			if(water + w < tankCapacity) water += w;
			else water = tankCapacity;
		}
		Skeleton.indentation--;

	}
	
	/**
	 * The implementation of the Step2 function of the Steppable interface
	 * If Output is closed( = -1) Skip it
	*/
	public void Step2() {
		Skeleton.Println(this.toString()+"Step2()");
		Skeleton.indentation++;
		if(output != -1) { // If output is open
			int w = GetNeighbor().get(output).PumpWater(water);
			if(water - w >= 0) water -= w;
			else water = 0;
		}
		Skeleton.indentation--;
	}
}
