package sivatagiVizhalozat;
//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Sivatagi Vizhalozat
//  @ File Name : Pipe.java
//  @ Date : 03/04/2023
//  @ Author : 
//
//


/** 
 * This class manages the pipe. It handles all of it is functions like puncturing it.
 * It also deals with new pumps being placed in the middle of it.
*/
public class Pipe extends FieldElement {

	static int nextId = 1;
	/**
	 * Stores the state of the Pipe if it is punctured or not
	*/
	private boolean isPunctured;

	/**
	 * Stores the state of the Pipe if it is grabbed or not
	*/
	private boolean isGrabbed;
	
	/**
	 * Stores the maximum amount of water the Pipe can keep
	*/
	private int capacity;
	
	/**
	 * Stores how much water is in the Pipe
	*/
	private int water;

	/**
	 * Stores how many turns until it can be puntured again
	 */
	private int unpuncturable;

	/**
	 * Stores how many turns until the pipe goes back the Normal state
	 */
	private int duration;

	/**
	 * Stores the current state of the pipes surface, if it slippery, sticky or normal
	 */
	private PipeSurfaceState state;

	
	/**
	 * Sets the value of the duration variable
	 * @param value The value to be set
	 */
	public void setDuration(int d) {
		if(d >= 0) duration = d;
	}

	/**
	 * Get the value of the duration variable
	 * @return How many time until pipe state goes normal
	 */
	public int getDuration() {
		return duration;
	}

	/**
	 * Sets the value of the nextId variable
	 * @param value The value to be set
	 */
	public void setNextId(int i) {
		nextId = i;
	}

	/**
	 * Get the value of the nextId variable
	 * @return What's going to be the next id of this class
	 */
	public int nextId() {
		return nextId;
	}

	/**
	 * Sets the value of the isPunctured variable
	 * @param value The value to be set
	 */
	public void setIsPunctured(boolean value) {
		isPunctured = value;
	}

	/**
	 * Get the value of the isPunctured variable
	 * @return True or false depending if it is punctured or not
	 */
	public boolean getIsPunctured() {
		return this.isPunctured;
	}

	/**
	 * Sets the value of the isGrabbed variable
	 * @param value The value to be set
	 */
	public void setIsGrabbed(boolean value) {
		isGrabbed = value;
	}

	/**
	 * Get the value of the isGrabbed variable
	 * @return True or false depemding if it is grabbed or not
	 */
	public boolean getIsGrabbed() {
		return isGrabbed;
	}

	/**
	 * Returns how much water is in the Pipe currently
	 * @return The amount of water that's in the pipe
	 */
	public int getWater() {
		return water;
	}

	/**
	 * Set how much water is in the Pipe 
	 * @param w The value of how much water is in the pipe
	 */
	public void setWater(int w) {
		water = w;
	}

	/**
	 * Set how much water can be in this pipe
	 * @param c The amount of water the pipe can hold
	 */
	public void setCapacity(int c) {
		capacity = c;
	}

	/**
	 * Get how much water can be in this pipe
	 * @return The amount of water this pipe can hold
	 */
	public int getCapacity() {
		return capacity;
	}

	/**
	 * Sets the state of the pipe, and if state is not normal sets the duration
	 * @param s The state the pipe is going to be set to
	 */
	public void setState(PipeSurfaceState s) {
		if(state == PipeSurfaceState.Normal) {
			if(s != PipeSurfaceState.Normal) {
			duration = (int)Math.round(game.getRandom()*10);
			}
		}
		else {
			if(s == PipeSurfaceState.Normal) {
				state = s;
				duration = 0;
			}
		}
	}

	/**
	 * Get the current state of the pipe
	 * @return The current state of the pipe
	 */
	public PipeSurfaceState getState() {
		return state;
	}

	/**
	 * Sets the value of the unpuncturable variable
	 * @param u The value to be set
	 */
	public void setUnpuncturable(int u) {
		if(u >= 0) unpuncturable = u;
	}

	/**
	 * Get the current value of the unpuncturable variable
	 * @return The current value of the unpuncturable variable
	 */
	public int getUnpuncturable() {
		return unpuncturable;
	}

	/**
	 * Default constructor
	 */
	public Pipe() {
		super();
		id = nextId++;
		isPunctured = false;
		isGrabbed = false;
		water = 0;
		capacity = 50;
		maxConnections = 2;
		state = PipeSurfaceState.Normal;
		duration = 0;
		unpuncturable = 0;
	}

	/**
	 * One parameter constructor
	 */
	public Pipe(Game g) {
		super(2,g);
		id = nextId++;
		isPunctured = false;
		isGrabbed = false;
		water = 0;
		capacity = 50;
		state = PipeSurfaceState.Normal;
		duration = 0;
		unpuncturable = 0;
	}

	/**
	 * Two parameter constructor
	 * @param g The Game object where this element is being used
	 * @param c The maximum amount of water that the pipe can hold
	 */
	public Pipe(Game g, int c) {
		super(2, g);
		id = nextId++;
		isPunctured = false;
		isGrabbed = false;
		water = 0;
		capacity = c;
		state = PipeSurfaceState.Normal;
		duration = 0;
		unpuncturable = 0;
	}

	/**
	 * Three parameter constructor
	 * @param g The Game object where this element is being used
	 * @param c The maximum amount of water that the pipe can hold
	 * @param w The amount of water in the Pipe
	 */
	public Pipe(Game g, int c, int w) {
		super(2, g);
		id = nextId++;
		isPunctured = false;
		isGrabbed = false;
		water = w;
		capacity = c;
		state = PipeSurfaceState.Normal;
		duration = 0;
		unpuncturable = 0;
	}

	/**
	 * The player tries to puncture the pipe it is standing on
	 * @return The successfulness of the command, if it was able to puncture the pipe
	*/
	public boolean Puncture() {
		if(!isPunctured && unpuncturable == 0) {
			isPunctured = true;	
			return true;
		}
		return false;
	}
	
	/**
	 * @param p The pump the player will place between the pipe it is standing on
	 * @return The successfulness of the command, if it was able to split the pipe and place the pump in-between the pipes
	*/
	public boolean Split(Pump p) {
		if(p != null && connections.size() == 2 && !isGrabbed) {
			Pipe newPipe = new Pipe(game, capacity, water/2);
			FieldElement a = connections.get(0);
			if(a.Remove(this) && Remove(a)) {
				p.Add(newPipe); p.Add(this);
				a.Add(newPipe);
				newPipe.Add(a); newPipe.Add(p);
				water = water/2;
				game.AddSteppable(p);
				return true;
			}
			a.Add(this); Add(this);
		}
		return false;
	}
	
	/**
	 * If this pipe can be grabbed it returns itself to be Grabbed,
	 * @return The grabbed pipe
	*/
	public Pipe Grab() {
		if(!isGrabbed && connections.size() == 1 && players.size() == 0) {
			isGrabbed = true;
			return this;
		}
		return null;
	}
	
	/**
	 * If the Pipe is punctured it repairs it
	 * @return The successfulness of the command, if it was able to repair this Pipe
	*/
	public boolean Repair() {
		if(isPunctured && !isGrabbed) {
			isPunctured = false;
			unpuncturable = 5;
			return true;
		}
		return false;
	}
	
	/**
	 * @param w The amount of water the element is able to receive
	 * @return The amount of water the pipe was able to pump into the element
	*/
	public int SuckWater(int w) {
		if(water > 0) {
			if(w >= water) {
				int ret = water;
				water = 0;
				return ret;
			}
			// The water that the element can accept is less than what's in the pipe
			else {
				water =- w;
				return w;
			}
		}
		return 0;
	}
	
	/**
	 * @param w The amount of water an element can pump water into a pipe
	 * @return The amount of water the pipe was able to accept 
	*/
	public int PumpWater(int w) {
		if(w > 0 && capacity > water) {
			if(w >= (capacity - water)) {
				int ret = capacity-water;
				water += ret;
				return ret;
			}
			else {
				water += w;
				return w;
			}
		}
		return 0;
	}
	
	/**
	 * The implementation of the Step1 function of the Steppable interface
	*/
	public void Step1() {
		if(game != null && !isGrabbed && (isPunctured || connections.size() == 1)) {
			game.WaterSpilled(water);
			water = 0;
		}
		if(state != PipeSurfaceState.Normal)  {
			if(duration > 0) duration--;
			else state = PipeSurfaceState.Normal;
		}
		if(unpuncturable > 0) unpuncturable--;
	}
	
	/**
	 * @param p A player that tries to step on this field
	 * @return The successfulness of the player stepping on this field
	*/
	public boolean StepOn(Player p) {
		if(p != null) {
			if(players.size() == 0) {
				if(p.GetLocation() != null) {
					p.GetLocation().StepOff(p);
				}

				p.SetLocation(this);
				players.add(p);

				if(state == PipeSurfaceState.Slippery) {
					if(game.getRandom() < 0.5) connections.get(0).StepOn(p);
					else connections.get(1).StepOn(p);
					state = PipeSurfaceState.Normal;
				}

				else if(state == PipeSurfaceState.Sticky) {
					p.setImmobile(duration);
					duration = 0;
					state = PipeSurfaceState.Normal;
				}

				return true;
			}
		}
		return false;
	}
	
	/**
	 * @param f The index of the connected element the player wants to remove the pipe from
	 * @return The disconnected pipe
	*/
	public Pipe Disconnect(int f) {
		if(players.size() == 0 && !isGrabbed) {
			if(f >= 0 && f < connections.size()) {
				Remove(connections.get(f));
				return this;
			}
		}
		return null;
	}

	/**
	 * Returns a string containing the data of the object
	 * @return A string containing the data of the object
	 */
	public String toString() {
		String ret = "id: " + getId()
		+ "\nmaxConnections: " + maxConnections 
		+ "\nstate: " + state 
		+ "\nisPunctured: " + ((isPunctured) ? "true" : "false")
		+ "\nisGrabbed: " + ((isGrabbed) ? "true" : "false")
		+ "\ncapacity: " + capacity
		+ "\nwater: " + water
		+ "unpuncturable: " + unpuncturable
		+ "duration: " + duration
		+ "connections: ";
		for (FieldElement neighbour : connections) {
			ret = ret.concat("\n");
			ret = ret.concat(neighbour.getClass().getSimpleName());
			ret = ret.concat(Integer.toString(neighbour.getId()));
		}
		ret = ret.concat("\nplayers: ");
		for (Player player : players) {
			ret = ret.concat("\n");
			ret = ret.concat(player.getClass().getSimpleName());
			ret = ret.concat(Integer.toString(player.getId()));
		}
		return ret;
	}
}
