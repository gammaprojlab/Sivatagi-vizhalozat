package sivatagiVizhalozat;
import java.util.ArrayList;
//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Untitled
//  @ File Name : FieldElement.java
//  @ Date : 03/04/2023
//  @ Author : 
//
//




/**
 * FieldElement:
 * An abstract class for all the placed elements on the board.
 * The main use is for the players to interact with other fields.
 * It fulfills an important role in finding the neighbouring elements.
 * To simulate water flow, it implements the Steppable interface
 */
public abstract class FieldElement implements Steppable {
	
	/**
	 * It stores how many connections a this element can have
	*/
	private int maxConections;
	
	/**
	 * It stores the fields that are connected to this element
	*/
	private ArrayList<FieldElement> connections;
	
	/**
	 * It stores the game element
	*/
	private Game game;
	
	/**
	 * It stores players standing on this element
	*/
	private ArrayList<Player> players;
	

	/**
	 * Add a new field to connections
	 * @param field The field to be added
	 */
	public boolean Add(FieldElement field) {
		if(field != null) {
			if (!GetNeighbor().contains(field) && connections.size() < maxConections) {
				connections.add(field);
				return true;
			}
		}
		return false;
	}

	/**
	 * Remove a field from connections
	 * @param field The field to be removed
	 */
	public boolean Remove(FieldElement field) {
		if(field != null) {
			if(GetNeighbor().contains(field)) {
				connections.remove(field);
				return true;
			}
		}
		return false;
	}

	/**
	 * @return A FieldElement ArrayList containing all the fields that are connected to this element
	*/
	public ArrayList<FieldElement> GetNeighbor() {
		return (connections != null) ? connections : null;
	}
	
	/**
	 * @param p A player that tries to step on this field
	 * @return The successfulness of the player stepping on this field
	*/
	public boolean StepOn(Player p) {
		if(p != null) {
			players.add(p);
			return true;
		}
		return false;
	}
	
	/**
	 * @param p A player that tries to leave this field
	 * @return The successfulness of the player leaving this field
	*/
	public boolean StepOff(Player p) {
		if(p != null) {
			if(players.contains(p)) {
				players.remove(p);
				return true;
			}
		}
		return false;
	}
	
	/**
	 * @param p A pipe object that we want to connect to this field
	 * @return The successfulness of connecting the pipe to this field
	*/
	public boolean Connect(Pipe p) {
		if(p !=  null) {
			ArrayList<FieldElement> pipeConnections = p.GetNeighbor();
			if (pipeConnections.contains(this)) return false;
			if(Add(p) && p.Add(this)) return true;
			Remove(p); p.Remove(this);
		}
		return false;
	}
	
	/**
	 * @param f The index of the pipe the player wants to disconnect from this field
	 * @return The disconnected pipe
	*/
	public Pipe Disconnect(int f) {
		return null;
	}
	
	/**
	 * The player tries to puncture the pipe it is standing on
	 * @return The successfulness of the command, if it was able to puncture the pipe
	*/
	public boolean Puncture() {
		return false;
	}
	
	/**
	 * @param p The pump the player will place between the pipe it is standing on
	 * @return The successfulness of the command, if it was able to split the pipe and place the pump in-between the pipes
	*/
	public boolean Split(Pump p) {
		return false;
	}
	
	/**
	 * It tries to grab a pipe it can from connections
	 * @return The grabbed pipe
	*/
	public Pipe Grab() {
		return null;
	}
	
	/**
	 * It repairs this field if it was broken
	 * @return The successfulness of the command, if it was able to repair this field
	*/
	public boolean Repair() {
		return false;
	}
	
	/**
	 * @param water The amount of water an element can pump water into a pipe
	 * @return The amount of water the pipe was able to accept 
	*/
	public int SuckWater(int water) {
		return 0;
	}
	
	/**
	 * @param water
	 * @return The amount of water the pipe was able to pump into the element
	*/
	public int PumpWater(int water) {
		return 0;
	}
	
	/** 
	 * If the cistern can create a new pump it creates one
	 * @return The created pump
	*/
	public Pump ProvidePump() {
		return null;
	}
	
	/**
	 * @param p1 The index of the pipe the player wants to set as input
	 * @param p2 The index of the pipe the player wants to set as output
	 * @return The successfulness of the command, if the player was able to change the direction
	*/
	public boolean ChangeDirection(int p1, int p2) {
		return false;
	}
	
	/**
	 * The implementation of the Step1 function of the Steppable interface
	*/
	public void Step1() {
	}
	
	/** 
	 * The implementation of the Step2 function of the Steppable interface
	*/
	public void Step2() {
	}
}
